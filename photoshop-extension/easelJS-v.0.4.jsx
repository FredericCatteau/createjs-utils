// PHOTOSHOP TO EASEL JS SPRITESHEET EXPORTER// enable double clicking from the Macintosh Finder or the Windows Explorer#target photoshop// in case we double clicked the fileapp.bringToFront();// debug level: 0-2 (0:disable, 1:break on error, 2:break at beginning)$.level = 1;// debugger; // launch debugger on next linevar layerIndex = 0 ;function main () {	// Check if we to have a doc to work with    if (app.documents.length == 0){                alert ("No document opened");		return;    }    var srcDoc = app.activeDocument;		// Switch to pixel units    var strtRulerUnits = app.preferences.rulerUnits;    if (strtRulerUnits != Units.PIXELS) {      app.preferences.rulerUnits = Units.PIXELS;    }            var w = srcDoc.width ;    var h = srcDoc.height ;        // TMP: TODO compute from w / h    var rows = 5;    var cols = 5;        	    var destDoc = srcDoc.duplicate("tmp", false);         destDoc.resizeCanvas (cols*w, rows*h, AnchorPosition.TOPLEFT);        // select target doc    app.activeDocument = destDoc;		var imageName = srcDoc.name.split(".")[0];	// TMP: TODO set the lib name	var libName = "spritelib";		// starting lib output	var txt = "//EaselJS Spritesheet\r ";	txt += "if (!window.myGame) { window.myGame = {}; }\r";	txt += "(function(scope) {\r";	txt += "var spritesheetPath='sprites/" + imageName + ".png';\r";    	// process each sprite		for (var i = 0 ; i < destDoc.layerSets.length ; i++) {		var spriteSet = destDoc.layerSets[i];		spriteSet.allLocked=false;		var destName = spriteSet.name;		var spriteTxt = processSprite(destDoc, spriteSet.layerSets, destName, cols, rows, w, h);		txt+= spriteTxt;			}		// end of lib output	txt += "// Endofspritesdef\r";	txt += "}(window.myGame));";    var destF =  Folder.selectDialog ("Select Destination");		if(destF){		var folderName = destF.absoluteURI+"/";		// save files		savePng(destDoc, folderName + imageName + ".png" );		saveTxt(txt, folderName + libName +".js");    		}         // close doc    destDoc.close(SaveOptions.DONOTSAVECHANGES);    // release refs    srcDoc = null;    destDoc = null;    // restore prefs    if (strtRulerUnits != app.preferences.rulerUnits) {      app.preferences.rulerUnits = strtRulerUnits;    }}function processSprite(doc, layerSets, destName, cols, rows, w, h) {	var t = "";    var animsTxt = "animations: {";    var framesTxt = "frames:[";	// stores the frame count for this sprite	var frameCount = 0 ;    for( var n = 0 ; n < layerSets.length ; n++){                var set = layerSets[n];		set.allLocked=false;        var setName = set.name;        $.writeln("Set: " + setName);                animsTxt += "\r\t" + setName + ":{ frames:[";                    for( var i = 0 ; i < set.layers.length ; i++){                        var layer = set.layers[i];            $.writeln("layer: " + layer.name);                        // discard text layers            if (layer.kind == LayerKind.TEXT) {                layerIndex++;				frameCount++;                continue;            }                        // select the next layer            doc.activeLayer = layer;            doc.activeLayer.allLocked=false;                        // compute destination            var destx = (layerIndex % cols) * w;            var desty = (Math.floor(layerIndex/cols)) * h;                        doc.activeLayer.translate(destx, desty);                        // Add frames : x, y, width, height, imageIndex, regX, regY            framesTxt += "\r\t[" + Number(destx) + ", " + Number(desty) + ", " + Number(w) + ", " + Number(h) + ", 0, 0, 0],";                        // Add frame index to animation data            animsTxt += frameCount + ", ";            // multiply frames as specified by the user            var sepIndex = layer.name.indexOf(" x");            if(sepIndex>-1) {                var repeat = Number(layer.name.slice(sepIndex+2));                for (var j = 0 ; j < repeat-1 ; j++)  animsTxt += frameCount + ", ";            }            			layerIndex++;			frameCount++;        } 		// TODO: deal with "next" parameter		// TODO: deal with "frequency" parameter		        animsTxt += "], frequency:4, next:true},";                            }		// sprite defintion	t += "\r// "+ destName + "\r" ;    		t += "var "+ destName +" = function() {this.initialize();}\r";    	t += destName + "._SpriteSheet = new createjs.SpriteSheet("    	t += "{images: [spritesheetPath], \r";	t += framesTxt;	t += "]";	t += ",\r"+animsTxt;	t += "}";    	t += "});\r";	t += "var "+ destName + "_p = " + destName + ".prototype = new createjs.BitmapAnimation();\r";	t += destName + "_p.BitmapAnimation_initialize = "+ destName + "_p.initialize;\r";	t += destName + "_p.initialize = function() {\r";	t += "\tthis.BitmapAnimation_initialize(" + destName + "._SpriteSheet);\r";	t += "\tthis.paused = false;\r"	t += "}\r";	t += "scope."+ destName + " = " + destName + ";\r";		return t;	}function savePng(doc, filepath) {                var pngFile = new File(filepath);    var pngFileOptions = new PNGSaveOptions();    doc.saveAs (pngFile, pngFileOptions, true, Extension.LOWERCASE);}function saveTxt(pText, filepath) {		    // get OS specific linefeed    var fileLineFeed;     if ($.os.search(/windows/i) != -1) {            fileLineFeed = "windows";    } else {		fileLineFeed = "macintosh";	}		    fileOut = new File(filepath);    fileOut.lineFeed = fileLineFeed;    fileOut.open("w", "TEXT", "????");    fileOut.write(pText);    fileOut.close();}main();